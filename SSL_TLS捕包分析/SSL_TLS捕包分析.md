[SSL/TLS捕包分析](https://www.cnblogs.com/lidong20179210/p/7868423.html)
====================================================================

03/16/2023 15:23:41本文共 5343 字阅读完需 21.5 分钟

### 一、基本概念

SSL：（Secure Socket Layer，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成：SSL记录协议和SSL握手协议。SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。

TLS：(Transport Layer Security，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。

TLS是在SSL的基础上标准化的产物，目前SSL3.0与TLS1.0保持一致的，二者是并列关系，只是大家习惯称呼SSL。注明的web服务nginx默认支持的就是TLS1.0、TLS1.1、TLS1.2协议。调用的openssl库中，对应的就是ssl3\_acceptt函数。

SSL/TLS位于传输层和应用层之间，应用层数据不再直接传递给传输层，而是传递给SSL层，SSL层对从应用层收到的数据进行加密，并增加自己的SSL头。

![](SSL_TLS%E6%8D%95%E5%8C%85%E5%88%86%E6%9E%90.assets/1272045-20171120211803618-1159826599.jpg) 

### 二、SSL/TLS在tcp/ip协议栈中的位置

SSL/TLS协议在传输层上封装了应用层的数据，因此可以在不需要修改应用层协议的前提下给不安全的应用层协议提供一定的安全保障。

![](SSL_TLS%E6%8D%95%E5%8C%85%E5%88%86%E6%9E%90.assets/1272045-20171120211900290-463646774.png)

### 三、SSL/TLS协议栈

![](SSL_TLS%E6%8D%95%E5%8C%85%E5%88%86%E6%9E%90.assets/1272045-20171120211945868-1929348361.png) 

### 四、过程

握手阶段，可分为5步

第一步，浏览器给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。

第二步，服务器确认双方使用的加密方法，使用的tls版本号和一个随机数。

第三部，并给出数字证书、以及一个服务器运行Diffie-Hellman算法生成的参数，比如pubkey。

第四部，浏览器获取服务器发来的pubkey，计算出另一个pubkey，发给服务器。

第五部，服务器发给浏览器一个session ticket。

![](SSL_TLS%E6%8D%95%E5%8C%85%E5%88%86%E6%9E%90.assets/1272045-20171120212020993-158106209.png)

![](SSL_TLS%E6%8D%95%E5%8C%85%E5%88%86%E6%9E%90.assets/1272045-20171120212046243-644093.png)

### 五、具体捕包

选择捕捉的是百度，经行了筛选ip.addr==119.75.217.109&& ssl

![](SSL_TLS%E6%8D%95%E5%8C%85%E5%88%86%E6%9E%90.assets/1272045-20171120212120540-1613395527.png)

### 1、SSL/TLS握手阶段抓包解析

### 1) 客户端发送ClientHello

客户端发起握手协商操作，它将发送一个ClientHello消息给服务器，消息中明确了其所支持的SSL/TLS版本、Cipher suite加密算法组合等，可以让服务器选择，并提供了一个客户端随机数，用于以后生成会话密钥使用。

![](SSL_TLS%E6%8D%95%E5%8C%85%E5%88%86%E6%9E%90.assets/1272045-20171120212211883-1497515026.png)

![](SSL_TLS%E6%8D%95%E5%8C%85%E5%88%86%E6%9E%90.assets/1272045-20171120212248602-1834285175.png)

ClientHello 客户发送CilentHello信息，包含如下内容：

（1）客户端可以支持的SSL最高版本号，这次捕获的版本是TLS1.0

（2）一个用于生成主秘密的32字节的随机数。（等会介绍主秘密是什么）

（3）一个确定会话的会话ID。

（4）一个客户端可以支持的密码套件列表。

密码套件格式：每个套件都以“TLS”开头，紧跟着的是密钥交换算法。用“With”这个词把密钥交换算法、加密算法、散列算法分开，例如：TLS\_ECDHE\_RSA\_WITH\_DES\_CBC\_SHA, 表示把DHE\_RSA(带有RSA数字签名的暂时ECDHE)定义为密钥交换算法；把DES\_CBC定义为加密算法；把SHA定义为散列算法。

（5）一个客户端可以支持的压缩算法列表。

### 2) 服务器返回ServerHello

服务器将返回一个ServerHello消息，该消息包含了服务器选择的协议版本、加密算法，以及服务器随机数、会话ID等内容。其中，服务器选择的协议版本应小于等于客户端ClientHello中的协议版本。

本次实验中服务器确认使用TLS 1.0版本的协议，并选择TLS\_ECDHE\_RSA\_WITH\_AES\_128\_CBC\_SHA256加密算法组合。

![](SSL_TLS%E6%8D%95%E5%8C%85%E5%88%86%E6%9E%90.assets/1272045-20171120212357727-1825492492.png)

ServerHello服务器用ServerHello信息应答客户，包括下列内容

（1）一个SSL版本号。取客户端支持的最高版本号和服务端支持的最高版本号中的较低者。

（2）一个用于生成主秘密的32字节的随机数。（客户端一个、服务端一个）

（3）会话ID

（4）从客户端的密码套件列表中选择的一个密码套件

（5）从客户端的压缩方法的列表中选择的压缩方法

这个阶段之后，客户端服务端知道了下列内容：

（1）SSL版本

（2）密钥交换、信息验证和加密算法

（3）压缩方法

（4）有关密钥生成的两个随机数。

### **3)****服务器鉴别与密钥交换**

服务器启动SSL握手第2阶段，是本阶段所有消息的唯一发送方，客户机是所有消息的唯一接收方。该阶段分为4步：

（a）证书Certificate：这一步很关键，是服务器给客户端展示证书的时候。服务器将数字证书和到根CA整个链发给客户端，使客户端能用服务器证书中的服务器公钥认证服务器。

（b）服务器密钥交换（可选）：这里视密钥交换算法而定

（c）证书请求：服务端可能会要求客户自身进行验证。

（d）服务器握手完成：第二阶段的结束，第三阶段开始的信号

![](SSL_TLS%E6%8D%95%E5%8C%85%E5%88%86%E6%9E%90.assets/1272045-20171120212530852-1651431660.png)

这里重点介绍一下服务端的验证和密钥交换。这个阶段的前面的（a）证书 和（b）服务器密钥交换是基于密钥交换方法的。而在SSL中密钥交换算法有6种：无效（没有密钥交换）、RSA、匿名Diffie-Hellman、暂时Diffie-Hellman、固定Diffie-Hellman、Fortezza。

在阶段1过程客户端与服务端协商的过程中已经确定使哪种密钥交换算法。

如果协商过程中确定使用RSA交换密钥，那么过程如下图：

![](SSL_TLS%E6%8D%95%E5%8C%85%E5%88%86%E6%9E%90.assets/1272045-20171120212621680-516062569.jpg)

这个方法中，服务器在它的第一个信息中，发送了RSA加密/解密公钥证书。不过，因为预备主秘密是由客户端在下一个阶段生成并发送的，所以第二个信息是空的。注意，公钥证书会进行从服务器到客户端的验证。当服务器收到预备主秘密时，它使用私钥进行解密。服务端拥有私钥是一个证据，可以证明服务器是一个它在第一个信息发送的公钥证书中要求的实体。

第一步、服务器发送Certificate

服务器发送ServerHello消息，选择好协议版本和加密算法组合后，将发送Certificate消息，该消息包含了服务器的证书等信息，可通过证书链认证该证书的真实性。根据选择的加密算法组合的不同，服务器证书中的公钥也可被用于加密后面握手过程中生成的Premaster secret。

![](SSL_TLS%E6%8D%95%E5%8C%85%E5%88%86%E6%9E%90.assets/1272045-20171120212720586-2006422222.png)

第二三步、服务器发送ServerKeyExchange

服务器发送ServerKeyExchange消息，消息中包含了服务器这边的EC Diffie-Hellman算法相关参数。此消息一般只在选择使用DHE 和DH\_anon等加密算法组合时才会由服务器发出。

第四步、服务器发送ServerHelloDone

服务器发送ServerHelloDone消息，告知客户端服务器这边握手相关的消息发送完毕。

![](SSL_TLS%E6%8D%95%E5%8C%85%E5%88%86%E6%9E%90.assets/1272045-20171120212814227-1712322070.png)

注意：在这里我们可以看到在Certificate后还紧跟着一个Certificate status。

![](SSL_TLS%E6%8D%95%E5%8C%85%E5%88%86%E6%9E%90.assets/1272045-20171120212841665-1644996226.png)

在客户端和服务器都表明支持OCSP stapling后，服务器在发送完Certificate消息后紧跟着发送Certificate Status消息，提供关于证书吊销的必要信息。

status\_request这个扩展用于表明客户端支持OCSP stapling。OCSP是一个检查证书吊销信息的协议，OCSP stapling机制可以使服务器向客户端发送最新的证书吊销信息，而无需客户端去访问CA的证书吊销列表。

![](SSL_TLS%E6%8D%95%E5%8C%85%E5%88%86%E6%9E%90.assets/1272045-20171120212927133-610531497.png)

4）**客户机鉴别与密钥交换：我们可以看到在这个地方**ClientKeyExchange、ChangeCipherSpec

、Finished（Encrypted Handshake Message）是被合并到了一条消息发送

![](SSL_TLS%E6%8D%95%E5%8C%85%E5%88%86%E6%9E%90.assets/1272045-20171120212956243-665513367.png)

4.1、客户端发送ClientKeyExchange

客户端发送ClientKeyExchange消息，消息中包含客户端这边的EC Diffie-Hellman算法相关参数，然后服务器和客户端都可根据接收到的对方参数和自身参数运算出Premaster secret，为生成会话密钥做准备。

![](SSL_TLS%E6%8D%95%E5%8C%85%E5%88%86%E6%9E%90.assets/1272045-20171120213044493-1070942519.png)

4.2、客户端发送ChangeCipherSpec

客户端切换成密文模式，客户端向服务器发送ChangeCipherSpec消息，通知服务器此消息以后客户端会以加密方式发送数据。

![](SSL_TLS%E6%8D%95%E5%8C%85%E5%88%86%E6%9E%90.assets/1272045-20171120213115618-1072886897.png)

4.3、客户端发送Finished

这个包表明握手已经完成，并且对之前发过的数据进行加密发送给对方做校验，防止被篡改。同时也验证一下，加密算法、密钥工作是否正常。客户端使用之前握手过程中获得的服务器随机数、客户端随机数、Premaster secret计算生成会话密钥，然后使用该会话密钥加密之前所有收发握手消息的Hash和MAC值，发送给服务器，服务器将相同的会话密钥（使用相同方法生成）解密此消息，校验其中的Hash和MAC值。

![](SSL_TLS%E6%8D%95%E5%8C%85%E5%88%86%E6%9E%90.assets/1272045-20171120213202102-966475949.png)

难点讲解：这一步是握手协议的阶段三，下面对这个阶段经行细致的讲解

![](SSL_TLS%E6%8D%95%E5%8C%85%E5%88%86%E6%9E%90.assets/1272045-20171120213257180-2004287259.png)

客户机启动SSL握手第3阶段，是本阶段所有消息的唯一发送方，服务器是所有消息的唯一接收方。该阶段分为3步：

（a）证书（可选）：为了对服务器证明自身，客户要发送一个证书信息，这是可选的，在IIS中可以配置强制客户端证书认证。

（b）客户机密钥交换（Pre-master-secret）：这里客户端将预备主密钥发送给服务端，注意这里会使用服务端的公钥进行加密。

（c）证书验证（可选），对预备秘密和随机数进行签名，证明拥有（a）证书的公钥。

### 　下面也重点介绍一下RSA方式的客户端验证和密钥交换。

![](SSL_TLS%E6%8D%95%E5%8C%85%E5%88%86%E6%9E%90.assets/1272045-20171120213346055-1483397463.jpg)

这种情况，除非服务器在阶段II明确请求，否则没有证书信息。客户端密钥交换方法包括阶段II收到的由RSA公钥加密的预备主密钥。

阶段III之后，客户要有服务器进行验证，客户和服务器都知道预备主密钥。

### 5）**完成**

![](SSL_TLS%E6%8D%95%E5%8C%85%E5%88%86%E6%9E%90.assets/1272045-20171120213508368-1029876455.png)

客户机启动SSL握手第4阶段，使服务器结束。该阶段分为4步，前2个消息来自客户机，后2个消息来自服务器。

具体捕包分析

![](SSL_TLS%E6%8D%95%E5%8C%85%E5%88%86%E6%9E%90.assets/1272045-20171120213604961-2083332478.png)

5.1、服务器发送ChangeCipherSpec

服务器发送ChangeCipherSpec消息，通知客户端此消息以后服务器会以加密方式发送数据。

![](SSL_TLS%E6%8D%95%E5%8C%85%E5%88%86%E6%9E%90.assets/1272045-20171120213628540-2044878147.png)

5.2、服务器发送Finished

服务器使用会话密钥加密（生成方式与客户端相同，使用握手过程中获得的服务器随机数、客户端随机数、Premaster secret计算生成）之前所有收发握手消息的Hash和MAC值，发送给客户端去校验。

若客户端服务器都校验成功，握手阶段完成，双方将按照SSL记录协议的规范使用协商生成的会话密钥加密发送数据。

![](SSL_TLS%E6%8D%95%E5%8C%85%E5%88%86%E6%9E%90.assets/1272045-20171120213658227-285849436.png)

### 　**2****、记录协议** 

###  ![](SSL_TLS%E6%8D%95%E5%8C%85%E5%88%86%E6%9E%90.assets/1272045-20171120213717930-1037075220.png)

记录协议在客户机和服务器握手成功后使用，即客户机和服务器鉴别对方和确定安全信息交换使用的算法后，进入SSL记录协议，记录协议向SSL连接提供两个服务：

（1）保密性：使用握手协议定义的秘密密钥实现

（2）完整性：握手协议定义了MAC，用于保证消息完整性

记录协议的过程：

![](SSL_TLS%E6%8D%95%E5%8C%85%E5%88%86%E6%9E%90.assets/1272045-20171120213820883-2097192929.png)

### 　　**3****、警报协议**

客户机和服务器发现错误时，向对方发送一个警报消息。如果是致命错误，则算法立即关闭SSL连接，双方还会先删除相关的会话号，秘密和密钥。每个警报消息共2个字节，第1个字节表示错误类型，如果是警报，则值为1，如果是致命错误，则值为2；第2个字节制定实际错误类型。

### 　　**总结**

SSL中，使用握手协议协商加密和MAC算法以及保密密钥 ，使用握手协议对交换的数据进行加密和签名，使用警报协议定义数据传输过程中，出现问题如何去解决。

**补充资料****密钥生成的过程**

这样握手协议完成，下面看下什么是预备主密钥，主密钥是怎么生成的。为了保证信息的完整性和机密性，SSL需要有六个加密秘密：四个密钥和两个IV。为了信息的可信性，客户端需要一个密钥（HMAC），为了加密要有一个密钥，为了分组加密要一个IV，服务也是如此。SSL需要的密钥是单向的，不同于那些在其他方向的密钥。如果在一个方向上有攻击，这种攻击在其他方向是没影响的。生成过程如下：

![](SSL_TLS%E6%8D%95%E5%8C%85%E5%88%86%E6%9E%90.assets/1272045-20171120213955368-432777872.png)

![](SSL_TLS%E6%8D%95%E5%8C%85%E5%88%86%E6%9E%90.assets/1272045-20171120214027586-563452044.png)

![](SSL_TLS%E6%8D%95%E5%8C%85%E5%88%86%E6%9E%90.assets/1272045-20171120214045993-1051016102.png)

参考的资料

https://en.wikipedia.org/wiki/Transport\_Layer\_Security

http://www.vuln.cn/6521

http://blog.csdn.net/fw0124/article/details/40983787

http://www.cnblogs.com/happyhippy/archive/2007/05/14/746476.html

http://blog.csdn.net/zgwangbo/article/details/50889623

http://kb.cnblogs.com/page/162080/

http://www.jianshu.com/p/7158568e4867